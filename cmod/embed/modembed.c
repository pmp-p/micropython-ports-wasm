/* http://github.com/pmp-p */
/*
  embed AUTO-GENERATED by /data/cross/micropython-git/master/ports/micropython-ports-wasm/modgen/__main__.py
*/


#include <string.h>
#include <stdio.h>

#include "py/obj.h"
#include "py/runtime.h"

static void print(mp_obj_t str) {
    mp_obj_print(str, PRINT_STR);
    mp_obj_print(mp_obj_new_str_via_qstr("\n",1), PRINT_STR);
}

static void null_pointer_exception(void){
    fprintf(stderr, "null pointer exception in function pointer call\n");
}

STATIC mp_obj_t PyBytes_FromString(char *string){
    vstr_t vstr;
    vstr_init_len(&vstr, strlen(string));
    strcpy(vstr.buf, string);
    return mp_obj_new_str_from_vstr(&mp_type_bytes, &vstr);
}

#define None mp_const_none
#define bytes(cstr) PyBytes_FromString(cstr)

    
// modgen
// python annotations describe the C types you need, argv is always a varialble size array of mp_obj_t.
// glue code will do its best to do the conversion or init.
//
// you *must* take care of return type yourself, glue code can only return None for you.

#ifndef __CPP__
#include <emscripten.h>
#endif

#include "py/emitglue.h"
#include "py/parse.h"
#include "py/lexer.h"
#include "py/compile.h"

#include <time.h>
#include <dlfcn.h>

#include "py/smallint.h"


extern char *repl_line;
extern int show_os_loop(int state);


extern mp_lexer_t* mp_lexer_new_from_file(const char *filename);
#if MICROPY_PERSISTENT_CODE_SAVE
extern void mp_raw_code_save_file(mp_raw_code_t *rc, const char *filename);
// Save .mpy file to file system
int raw_code_save_file(mp_raw_code_t *rc, const char *filename) {  return 0; }
#endif

mp_obj_t execute_from_str(const char *str) {
    nlr_buf_t nlr;
    if (nlr_push(&nlr) == 0) {
        qstr src_name = 1/*MP_QSTR_*/;
        mp_lexer_t *lex = mp_lexer_new_from_str_len(src_name, str, strlen(str), false);
        mp_parse_tree_t pt = mp_parse(lex, MP_PARSE_FILE_INPUT);
        mp_obj_t module_fun = mp_compile(&pt, src_name, MP_EMIT_OPT_NONE, false);
        mp_call_function_0(module_fun);
        nlr_pop();
        return 0;
    } else {
        // uncaught exception
        return (mp_obj_t)nlr.ret_val;
    }
}



STATIC void coropass(void) {
    const char sched[] =
        "__module__ = __import__('sys').modules.get('asyncio',None);"
        "__module__ = __module__ and __module__.get_event_loop().step()";

    const char *sched_ptr = &sched[0];
    execute_from_str( sched_ptr);
    MP_STATE_PORT(coro_call_counter++);
}



/* #1@63 os_print( data : const_char_p = "{}" ) -> void  */

STATIC mp_obj_t //ptr
embed_os_print(size_t argc, const mp_obj_t *argv) {

    const char *data;
    if (argc>0)
        data = mp_obj_str_get_str(argv[0]);
    else
        data = mp_obj_new_str_via_qstr("{}",2);

//   #fprintf( stderr, "embed.os_write(%lu)\n", strlen(data) );
    fprintf( stdout , "%s\n" , data );
    return None;
} /* os_print */

/* #2@68 os_write( data : const_char_p = "{}" ) -> void  */

STATIC mp_obj_t //ptr
embed_os_write(size_t argc, const mp_obj_t *argv) {

    const char *data;
    if (argc>0)
        data = mp_obj_str_get_str(argv[0]);
    else
        data = mp_obj_new_str_via_qstr("{}",2);

//   #fprintf( stderr, "embed.os_write(%lu)\n", strlen(data) );
    fprintf( stdout , "%s" , data );
    return None;
} /* os_write */

/* #3@73 os_stderr( data : const_char_p = "" ) -> void  */

STATIC mp_obj_t //ptr
embed_os_stderr(size_t argc, const mp_obj_t *argv) {

    const char *data;
    if (argc>0)
        data = mp_obj_str_get_str(argv[0]);
    else
        data = mp_obj_new_str_via_qstr("",0);

    fprintf( stderr, "embed.os_stderr(%s)\n", data );
    return None;
} /* os_stderr */

/* #4@77 log( data : const_char_p = "" ) -> void  */

STATIC mp_obj_t //ptr
embed_log(size_t argc, const mp_obj_t *argv) {

    const char *data;
    if (argc>0)
        data = mp_obj_str_get_str(argv[0]);
    else
        data = mp_obj_new_str_via_qstr("",0);

    fprintf( stderr, "%s\n", data );
    return None;
} /* log */


/* #5@82 builtins_vars(module_obj : mp_obj_t = None ) -> dict  */

STATIC mp_obj_t //dict
embed_builtins_vars(size_t argc, const mp_obj_t *argv) {

    mp_obj_t* module_obj;
    if (argc>0)
        module_obj = (mp_obj_t*)argv[0];
    else module_obj = NULL ;


    mp_obj_dict_t *mod_globals = mp_obj_module_get_globals(module_obj);
    return mod_globals;
    //return dict()
} /* builtins_vars */


/* #6@88 os_compile(source_file : const_char_p="", mpy_file : const_char_p="") -> void  */

STATIC mp_obj_t //ptr
embed_os_compile(size_t argc, const mp_obj_t *argv) {

    const char *source_file;
    if (argc>0)
        source_file = mp_obj_str_get_str(argv[0]);
    else
        source_file = mp_obj_new_str_via_qstr("",0);


    const char *mpy_file;
    if (argc>1)
        mpy_file = mp_obj_str_get_str(argv[1]);
    else
        mpy_file = mp_obj_new_str_via_qstr("",0);

    vstr_t vstr;

    if (argc == 2 && argv[1] != mp_const_none) {
        //done by glue code
    } else {
        vstr_init(&vstr, strlen(source_file) + 5);  // +5 for NUL and .mpy
        vstr_add_str(&vstr, source_file);
        if (vstr.len > 3 && memcmp(&vstr.buf[vstr.len - 3], ".py", 3) == 0) {
            // remove .py extension to replace with .mpy
            vstr_cut_tail_bytes(&vstr, 3);
        }
        vstr_add_str(&vstr, ".mpy");
        mpy_file = vstr_null_terminated_str(&vstr);
    }
    #if MICROPY_PERSISTENT_CODE_SAVE
    mp_lexer_t *lex = mp_lexer_new_from_file(source_file);
    mp_parse_tree_t parse_tree = mp_parse(lex, MP_PARSE_FILE_INPUT);

    mp_raw_code_t *rc = mp_compile_to_raw_code(&parse_tree,
                                               qstr_from_str(source_file),
                                               MP_EMIT_OPT_NONE,
                                               false);

    mp_raw_code_save_file(rc, mpy_file);
    #else
    fprintf(stderr,"os_compile: MICROPY_PERSISTENT_CODE_SAVE not enabled\n");
    #endif
    return None;
} /* os_compile */

/* #7@118 os_showloop()->void  */

STATIC mp_obj_t //ptr
embed_os_showloop(size_t argc, const mp_obj_t *argv) {
    fprintf(stderr,"will show begin/end for os loop\n");
    show_os_loop(1);
    return None;
} /* os_showloop */


/* #8@124 os_hook() ->void  */

STATIC mp_obj_t //ptr
embed_os_hook(size_t argc, const mp_obj_t *argv) {
    void (*void_ptr)(int) = MP_STATE_PORT(PyOS_InputHook);
    if ( void_ptr != NULL ) {
        printf("PyOS_InputHook %p TODO: allow py callback ptr\n", void_ptr);
    } else {
        printf("PyOS_InputHook undef TODO: allow py callback ptr\n");
        if ( !MP_STATE_PORT(coro_call_counter)) {
            MP_STATE_PORT(PyOS_InputHook) = &coropass ;
            printf("coro task started\n");
            coropass();
        }
    }
    return None;
} /* os_hook */

// https://www.python.org/dev/peps/pep-0564/
//    https://vstinner.github.io/python37-pep-564-nanoseconds.html
/* #9@140 time_ns() -> int  */

STATIC mp_obj_t //int
embed_time_ns(size_t argc, const mp_obj_t *argv) {
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    //unsigned long ul = ts.tv_nsec ;
    return mp_obj_new_int_from_uint( ts.tv_nsec );
    //return int()
} /* time_ns */

// upy
/* #10@148 time_ms() -> int  */

STATIC mp_obj_t //int
embed_time_ms(size_t argc, const mp_obj_t *argv) {
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    //unsigned long ul = ts.tv_nsec * 1000000 ;
    return mp_obj_new_int_from_uint( ts.tv_nsec * 1000000);
    //return int()
} /* time_ms */

/* #11@155 ticks_add(ticks : int=0, delta : int=0)->int  */

STATIC mp_obj_t //int
embed_ticks_add(size_t argc, const mp_obj_t *argv) {

    int ticks;
    if (argc>0)
        ticks = mp_obj_get_int(argv[0]);
    else ticks = 0 ;



    int delta;
    if (argc>1)
        delta = mp_obj_get_int(argv[1]);
    else delta = 0 ;


    return mp_obj_new_int_from_uint( ticks + delta );
    //return int()
} /* ticks_add */


/* #12@160 sleep_ms(ms : int =0) -> void  */

STATIC mp_obj_t //ptr
embed_sleep_ms(size_t argc, const mp_obj_t *argv) {

    int ms;
    if (argc>0)
        ms = mp_obj_get_int(argv[0]);
    else ms = 0 ;


    //emscripten_sleep_with_yield( ms );
    emscripten_sleep(ms);
    return None;
} /* sleep_ms */

/* #13@165 sleep(s : float =0) -> void  */

STATIC mp_obj_t //ptr
embed_sleep(size_t argc, const mp_obj_t *argv) {

    int s;
    if (argc>0)
        s = mp_obj_get_float(argv[0]);
    else s = 0 ;


    emscripten_sleep( (int)(s*1000) );
    return None;
} /* sleep */


/* #14@170 ticks_period() -> int  */

STATIC mp_obj_t //int
embed_ticks_period(size_t argc, const mp_obj_t *argv) {
    return mp_obj_new_int_from_uint( MICROPY_PY_UTIME_TICKS_PERIOD );
    //return int()
} /* ticks_period */


/* #15@175 os_read() -> bytes  */

STATIC mp_obj_t //bytes
embed_os_read(size_t argc, const mp_obj_t *argv) {
    return bytes( repl_line );
    //return bytes()
} /* os_read */

// TODO: remove after tests


/* #16@182 os_read_useless() -> bytes  */

STATIC mp_obj_t //bytes
embed_os_read_useless(size_t argc, const mp_obj_t *argv) {
    // simple read string

    static char buf[256];
    //fputs(p, stdout);
    char *s = fgets(buf, sizeof(buf), stdin);
    if (!s) {
        //return mp_obj_new_int(0);
        buf[0]=0;
        fprintf(stderr,"embed.os_read EOF\n" );
    } else {
        int l = strlen(buf);
        if (buf[l - 1] == '\n') {
            if ( (l>1) && (buf[l - 2] == '\r') )
                buf[l - 2] = 0;
            else
                buf[l - 1] = 0;
        } else {
            l++;
        }
        fprintf(stderr,"embed.os_read [%s]\n", buf );
    }
    return bytes(buf);
    //return bytes()
} /* os_read_useless */
//   # py comment #1


/* #17@209 echosum1(num : int=0) -> int  */

STATIC mp_obj_t //int
embed_echosum1(size_t argc, const mp_obj_t *argv) {

    int num;
    if (argc>0)
        num = mp_obj_get_int(argv[0]);
    else num = 0 ;


    return MP_OBJ_NEW_SMALL_INT(num+1);
    //return int()
} /* echosum1 */

// py comment #2

/* #18@215 callsome(fn : void=npe) -> void  */

STATIC mp_obj_t //ptr
embed_callsome(size_t argc, const mp_obj_t *argv) {

    void (*fn)(void);
    if (argc>0)
        fn = (void*)argv[0] ;
    else fn = &null_pointer_exception;


    (*fn)();
    return None;
} /* callsome */


/* #19@220 somecall(s:str='pouet')  */

STATIC mp_obj_t //void
embed_somecall(size_t argc, const mp_obj_t *argv) {

    mp_obj_t s;
    if (argc>0)
        s = (mp_obj_t*)argv[0];
    else s =  mp_obj_new_str_via_qstr("pouet",5);


    fprintf(stderr, "FPRINTF[%s]\n", mp_obj_str_get_str(s) );
    print(s);
    return None;
} /* somecall */

// c comment #3



/***************************** MODULE INTERFACE ***************************/

STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(embed_builtins_vars_obj,
    0, 1, embed_builtins_vars);

STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(embed_callsome_obj,
    0, 1, embed_callsome);

STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(embed_echosum1_obj,
    0, 1, embed_echosum1);

STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(embed_log_obj,
    0, 1, embed_log);

STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(embed_os_compile_obj,
    0, 2, embed_os_compile);

STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(embed_os_hook_obj,
    0, 0, embed_os_hook);

STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(embed_os_print_obj,
    0, 1, embed_os_print);

STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(embed_os_read_obj,
    0, 0, embed_os_read);

STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(embed_os_read_useless_obj,
    0, 0, embed_os_read_useless);

STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(embed_os_showloop_obj,
    0, 0, embed_os_showloop);

STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(embed_os_stderr_obj,
    0, 1, embed_os_stderr);

STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(embed_os_write_obj,
    0, 1, embed_os_write);

STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(embed_sleep_obj,
    0, 1, embed_sleep);

STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(embed_sleep_ms_obj,
    0, 1, embed_sleep_ms);

STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(embed_somecall_obj,
    0, 1, embed_somecall);

STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(embed_ticks_add_obj,
    0, 2, embed_ticks_add);

STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(embed_ticks_period_obj,
    0, 0, embed_ticks_period);

STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(embed_time_ms_obj,
    0, 0, embed_time_ms);

STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(embed_time_ns_obj,
    0, 0, embed_time_ns);

STATIC const mp_map_elem_t embed_globals_table[] = {
    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_embed) },
    { MP_ROM_QSTR(MP_QSTR___file__), MP_ROM_QSTR(MP_QSTR_flashrom) },

    {MP_ROM_QSTR(MP_QSTR_builtins_vars), (mp_obj_t)&embed_builtins_vars_obj },
    {MP_ROM_QSTR(MP_QSTR_callsome), (mp_obj_t)&embed_callsome_obj },
    {MP_ROM_QSTR(MP_QSTR_echosum1), (mp_obj_t)&embed_echosum1_obj },
    {MP_ROM_QSTR(MP_QSTR_log), (mp_obj_t)&embed_log_obj },
    {MP_ROM_QSTR(MP_QSTR_os_compile), (mp_obj_t)&embed_os_compile_obj },
    {MP_ROM_QSTR(MP_QSTR_os_hook), (mp_obj_t)&embed_os_hook_obj },
    {MP_ROM_QSTR(MP_QSTR_os_print), (mp_obj_t)&embed_os_print_obj },
    {MP_ROM_QSTR(MP_QSTR_os_read), (mp_obj_t)&embed_os_read_obj },
    {MP_ROM_QSTR(MP_QSTR_os_read_useless), (mp_obj_t)&embed_os_read_useless_obj },
    {MP_ROM_QSTR(MP_QSTR_os_showloop), (mp_obj_t)&embed_os_showloop_obj },
    {MP_ROM_QSTR(MP_QSTR_os_stderr), (mp_obj_t)&embed_os_stderr_obj },
    {MP_ROM_QSTR(MP_QSTR_os_write), (mp_obj_t)&embed_os_write_obj },
    {MP_ROM_QSTR(MP_QSTR_sleep), (mp_obj_t)&embed_sleep_obj },
    {MP_ROM_QSTR(MP_QSTR_sleep_ms), (mp_obj_t)&embed_sleep_ms_obj },
    {MP_ROM_QSTR(MP_QSTR_somecall), (mp_obj_t)&embed_somecall_obj },
    {MP_ROM_QSTR(MP_QSTR_ticks_add), (mp_obj_t)&embed_ticks_add_obj },
    {MP_ROM_QSTR(MP_QSTR_ticks_period), (mp_obj_t)&embed_ticks_period_obj },
    {MP_ROM_QSTR(MP_QSTR_time_ms), (mp_obj_t)&embed_time_ms_obj },
    {MP_ROM_QSTR(MP_QSTR_time_ns), (mp_obj_t)&embed_time_ns_obj },

};

STATIC MP_DEFINE_CONST_DICT(mp_module_embed_globals, embed_globals_table);

const mp_obj_module_t mp_module_embed = {
    .base = { &mp_type_module },
    .globals = (mp_obj_dict_t*)&mp_module_embed_globals,
};

// Register the module to make it available
MP_REGISTER_MODULE(MP_QSTR_embed, mp_module_embed, MODULE_EMBED_ENABLED);

